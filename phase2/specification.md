# Specification / Functionality 
First we will summarize our original specification. We originally sought out to have a program that did the following:
1. Process a command
2. Execute the command (if you can)
3. Return the result

Using this, we wanted a textual environment where the user could interact with objects, defeat enemies, and gain progress in the game. We ended up fully satisfying this specification.  Our game supports choosing one of multiple quests. Then from these quests, going into missions or free game mode. You can follow a series of missions to complete the quest, or, play around with the side interactions intermediately. On top of this, all of our interactables have unique interactions with the player. You can consume foods, harvest resources, fight enemies, and do neutral things as well like solving riddles and opening doors. Additionally, congruent with our goals in our specification, we can even add new game objects and interactables to add new diversity to our project. In phase 2 we intend to demonstrate this by adding many more minigames, interactions and interactables, and game objects to really make the game a medieval textual game.

In regards to the goal of our customizability of the game, we didn’t satisfy this not because we couldn’t, but when critically thinking about this feature realized it wasn’t something to “code” and was more a “side effect” of our game itself. Since we have strict structure with our game flow, as a result developers can add their own game objects easily and it will be incorporated into the game, but this isn’t so much a feature as much as it is a nice perk.

We think the functionality is extremely ambitious. We set out to make a full fledged textual virtual world, basically, compressed and formatted into a game. In our honest opinion, we think we came pretty close to accomplishing this in a clean and effective manner. We recognize there will be weaknesses, but there were time constraints and many other priorities so with all that considered, we think the quality of our code, and how well it represents a virtual environment textually in our game, was a very ambitious task for us to accomplish. Addressing the save/load state question, our program saves results and game information in GameState and PlayerManager, and references this (loads it) in different encounters. However, it does not save and write to a file, then load from that file for the next use of the program. This is a goal for us, and something that can be easily implemented by just saving the GameState information along with the encounter’s setting, but this would require some restructuring and we did not want to risk worsening our project before submission. It is a phase 2 goal of ours that we intend to accomplish.

Building on this, we successfully added a save and load state feature in Phase 2 to fully satisfy the specification requirements. This allows the user to save and load their game progress, raising our functionality to another level.

To do this, as per the specification requirements we used sterilizations. Specifically, in order to save the state of the game we serialized the object that holds the current state of the game - GameState and serialized all of the related objects to GameState that were too complicated to store simply, those objects specifically being the player and the encounters.

To do so, we used the library Gson, which converts objects into a string that is a Json representation of the object and then can convert the strings back into their corresponding object. Using Gson alone was not sufficient enough however specifically for the player and the encounters as they contained polymorphic collections, where the sub-type information was key for our program functionality. Json alone does not store type information so we needed to use an external add-on to the Gson library, RuntimeTypeadapterFactory in order to preserve this type information. Since we had multiple polymorphic collections then we had to serialize the objects that contained them (Player, encounter) as we could not use one instance of Gson to convert the objects into their string representations and as such had to create our own format.

An additional complication also came up is that specific interactable objects need to store a reference to the player in order to function correctly. If we were to convert those interactables to Json strings and then convert them back, all of the interactables would reference different identical copies of the player character and not the same object, so in the deserialization process we had to account for that.

With this change, we added more interactables and minigames such as Joust and Maze (in minigames). This was mainly to add diversity to our game, and demonstrate its expandability.  
