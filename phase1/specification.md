# Specification / Functionality 
First we will summarize our original specification. We originally sought out to have a program that did the following:
1. Process a command

2. Execute the command (if you can)

3. Return the result

Using this, we wanted a textual environment where the user could interact with objects, defeat enemies, and gain progress in the game. We ended up fully satisfying this specification.  Our game supports choosing one of multiple quests. Then from these quests, going into missions or free game mode. You can follow a series of missions to complete the quest, or, play around with the side interactions intermediately. On top of this, all of our interactables have uniqu##e interactions with the player. You can consume foods, harvest resources, fight enemies, and do neutral things as well like solving riddles and opening doors. Additionally, congruent with our goals in our specification, we can even add new game objects and interactables to add new diversity to our project. In phase 2 we intend to demonstrate this by adding many more minigames, interactions and interactables, and game objects to really make the game a medieval textual game.

In regards to the goal of our customizability of the game, we didn’t satisfy this not because we couldn’t, but when critically thinking about this feature realized it wasn’t something to “code” and was more a “side effect” of our game itself. Since we have strict structure with our game flow, as a result developers can add their own game objects easily and it will be incorporated into the game, but this isn’t so much a feature as much as it is a nice perk.

We think the functionality is extremely ambitious. We set out to make a full fledged textual virtual world, basically, compressed and formatted into a game. In our honest opinion, we think we came pretty close to accomplishing this in a clean and effective manner. We recognize there will be weaknesses, but there were time constraints and many other priorities so with all that considered, we think the quality of our code, and how well it represents a virtual environment textually in our game, was a very ambitious task for us to accomplish. Addressing the save/load state question, our program saves results and game information in GameState and PlayerManager, and references this (loads it) in different encounters. However, it does not save and write to a file, then load from that file for the next use of the program. This is a goal for us, and something that can be easily implemented by just saving the GameState information along with the encounter’s setting, but this would require some restructuring and we did not want to risk worsening our project before submission. It is a phase 2 goal of ours that we intend to accomplish.
